/**
This Unit Test Suite was auto-generated
DO NOT EDIT THIS FILE MANUALLY
 */


#include <gtest/gtest.h>
#include "slic.hpp"
#include <opencv2/core.hpp>
#include <opencv2/imgproc.hpp>

using namespace ltridp;

// ============================================================================
// Test Fixture
// ============================================================================

class LTriDPSLICTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Create small test images (100Ã—100)
        test_image = cv::Mat(100, 100, CV_8UC1);
        test_texture = cv::Mat(100, 100, CV_8UC1);
        
        // Fill with gradients for predictable behavior
        for (int y = 0; y < 100; ++y) {
            for (int x = 0; x < 100; ++x) {
                test_image.at<uchar>(y, x) = static_cast<uchar>(x + y);
                test_texture.at<uchar>(y, x) = static_cast<uchar>(x * 2);
            }
        }
    }
    
    cv::Mat test_image;
    cv::Mat test_texture;
};

// ============================================================================
// Input Validation Tests
// ============================================================================

TEST_F(LTriDPSLICTest, RejectsEmptyImage) {
    cv::Mat empty;
    EXPECT_THROW({
        LTriDPSuperpixelSLIC slic(empty, test_texture);
    }, std::invalid_argument);
}

TEST_F(LTriDPSLICTest, RejectsEmptyTexture) {
    cv::Mat empty;
    EXPECT_THROW({
        LTriDPSuperpixelSLIC slic(test_image, empty);
    }, std::invalid_argument);
}

TEST_F(LTriDPSLICTest, RejectsNonGrayscaleImage) {
    cv::Mat color(100, 100, CV_8UC3);
    EXPECT_THROW({
        LTriDPSuperpixelSLIC slic(color, test_texture);
    }, std::invalid_argument);
}

TEST_F(LTriDPSLICTest, RejectsMismatchedDimensions) {
    cv::Mat small_texture(50, 50, CV_8UC1);
    EXPECT_THROW({
        LTriDPSuperpixelSLIC slic(test_image, small_texture);
    }, std::invalid_argument);
}

TEST_F(LTriDPSLICTest, RejectsInvalidRegionSize) {
    EXPECT_THROW({
        LTriDPSuperpixelSLIC slic(test_image, test_texture, 0);
    }, std::invalid_argument);
    
    EXPECT_THROW({
        LTriDPSuperpixelSLIC slic(test_image, test_texture, -5);
    }, std::invalid_argument);
}

TEST_F(LTriDPSLICTest, RejectsInvalidRuler) {
    EXPECT_THROW({
        LTriDPSuperpixelSLIC slic(test_image, test_texture, 20, 0.0f);
    }, std::invalid_argument);
    
    EXPECT_THROW({
        LTriDPSuperpixelSLIC slic(test_image, test_texture, 20, -1.0f);
    }, std::invalid_argument);
}

// ============================================================================
// Initialization Tests
// ============================================================================

TEST_F(LTriDPSLICTest, InitializesWithValidInputs) {
    EXPECT_NO_THROW({
        LTriDPSuperpixelSLIC slic(test_image, test_texture, 20, 10.0f);
    });
}

TEST_F(LTriDPSLICTest, GeneratesReasonableNumberOfSuperpixels) {
    LTriDPSuperpixelSLIC slic(test_image, test_texture, 20, 10.0f);
    
    int num_sp = slic.getNumberOfSuperpixels();
    
    // Expected: ~(100*100)/(20*20) = 25 superpixels
    EXPECT_GT(num_sp, 10);  // Should have multiple superpixels
    EXPECT_LT(num_sp, 100); // Shouldn't be too many
}

TEST_F(LTriDPSLICTest, SmallRegionSizeCreatesMoreSuperpixels) {
    LTriDPSuperpixelSLIC slic_small(test_image, test_texture, 10, 10.0f);
    LTriDPSuperpixelSLIC slic_large(test_image, test_texture, 30, 10.0f);
    
    EXPECT_GT(slic_small.getNumberOfSuperpixels(), 
              slic_large.getNumberOfSuperpixels());
}

// ============================================================================
// Iteration Tests
// ============================================================================

TEST_F(LTriDPSLICTest, IterateWithValidCount) {
    LTriDPSuperpixelSLIC slic(test_image, test_texture);
    EXPECT_NO_THROW({
        slic.iterate(10);
    });
}

TEST_F(LTriDPSLICTest, RejectsZeroIterations) {
    LTriDPSuperpixelSLIC slic(test_image, test_texture);
    EXPECT_THROW({
        slic.iterate(0);
    }, std::invalid_argument);
}

TEST_F(LTriDPSLICTest, RejectsNegativeIterations) {
    LTriDPSuperpixelSLIC slic(test_image, test_texture);
    EXPECT_THROW({
        slic.iterate(-5);
    }, std::invalid_argument);
}

// ============================================================================
// Label Output Tests
// ============================================================================

TEST_F(LTriDPSLICTest, GetLabelsReturnsCorrectSize) {
    LTriDPSuperpixelSLIC slic(test_image, test_texture);
    slic.iterate(5);
    
    cv::Mat labels;
    slic.getLabels(labels);
    
    EXPECT_EQ(labels.rows, test_image.rows);
    EXPECT_EQ(labels.cols, test_image.cols);
    EXPECT_EQ(labels.type(), CV_32S);
}

TEST_F(LTriDPSLICTest, LabelsAreInValidRange) {
    LTriDPSuperpixelSLIC slic(test_image, test_texture);
    slic.iterate(5);
    
    cv::Mat labels;
    slic.getLabels(labels);
    
    int num_sp = slic.getNumberOfSuperpixels();
    
    // Check all labels are in valid range
    double min_val, max_val;
    cv::minMaxLoc(labels, &min_val, &max_val);
    
    EXPECT_GE(min_val, 0);
    EXPECT_LT(max_val, num_sp);
}

TEST_F(LTriDPSLICTest, AllSuperpixelLabelsUsed) {
    LTriDPSuperpixelSLIC slic(test_image, test_texture);
    slic.iterate(10);
    
    cv::Mat labels;
    slic.getLabels(labels);
    
    int num_sp = slic.getNumberOfSuperpixels();
    
    // Count unique labels
    std::set<int> unique_labels;
    for (int y = 0; y < labels.rows; ++y) {
        for (int x = 0; x < labels.cols; ++x) {
            unique_labels.insert(labels.at<int>(y, x));
        }
    }
    
    // Should use most labels (some may be merged)
    EXPECT_GT(unique_labels.size(), static_cast<size_t>(num_sp * 0.8));
}

// ============================================================================
// Contour Mask Tests
// ============================================================================

TEST_F(LTriDPSLICTest, ContourMaskHasCorrectFormat) {
    LTriDPSuperpixelSLIC slic(test_image, test_texture);
    slic.iterate(5);
    
    cv::Mat mask;
    slic.getLabelContourMask(mask);
    
    EXPECT_EQ(mask.rows, test_image.rows);
    EXPECT_EQ(mask.cols, test_image.cols);
    EXPECT_EQ(mask.type(), CV_8UC1);
}

TEST_F(LTriDPSLICTest, ContourMaskIsBinary) {
    LTriDPSuperpixelSLIC slic(test_image, test_texture);
    slic.iterate(5);
    
    cv::Mat mask;
    slic.getLabelContourMask(mask);
    
    // Check all values are 0 or 255
    for (int y = 0; y < mask.rows; ++y) {
        for (int x = 0; x < mask.cols; ++x) {
            uchar val = mask.at<uchar>(y, x);
            EXPECT_TRUE(val == 0 || val == 255);
        }
    }
}

TEST_F(LTriDPSLICTest, ContourMaskContainsBoundaries) {
    LTriDPSuperpixelSLIC slic(test_image, test_texture);
    slic.iterate(5);
    
    cv::Mat mask;
    slic.getLabelContourMask(mask);
    
    // Should have some boundary pixels
    int boundary_count = cv::countNonZero(mask);
    EXPECT_GT(boundary_count, 0);
}

TEST_F(LTriDPSLICTest, ThickLineProducesMoreBoundaryPixels) {
    LTriDPSuperpixelSLIC slic(test_image, test_texture);
    slic.iterate(5);
    
    cv::Mat thick_mask, thin_mask;
    slic.getLabelContourMask(thick_mask, true);
    slic.getLabelContourMask(thin_mask, false);
    
    int thick_count = cv::countNonZero(thick_mask);
    int thin_count = cv::countNonZero(thin_mask);
    
    // Both should produce boundaries (actual relationship may vary)
    // The thick_line parameter affects the threshold, not necessarily the count
    EXPECT_GT(thick_count, 0);
    EXPECT_GT(thin_count, 0);
}

// ============================================================================
// Connectivity Enforcement Tests
// ============================================================================

TEST_F(LTriDPSLICTest, EnforceConnectivityWithValidParameter) {
    LTriDPSuperpixelSLIC slic(test_image, test_texture);
    slic.iterate(5);
    
    EXPECT_NO_THROW({
        slic.enforceLabelConnectivity(25);
    });
}

TEST_F(LTriDPSLICTest, EnforceConnectivityWithZeroParameter) {
    LTriDPSuperpixelSLIC slic(test_image, test_texture);
    slic.iterate(5);
    
    // Should do nothing, not throw
    EXPECT_NO_THROW({
        slic.enforceLabelConnectivity(0);
    });
}

TEST_F(LTriDPSLICTest, EnforceConnectivityRejectsInvalidParameter) {
    LTriDPSuperpixelSLIC slic(test_image, test_texture);
    slic.iterate(5);
    
    EXPECT_THROW({
        slic.enforceLabelConnectivity(-1);
    }, std::invalid_argument);
    
    EXPECT_THROW({
        slic.enforceLabelConnectivity(150);
    }, std::invalid_argument);
}

TEST_F(LTriDPSLICTest, EnforceConnectivityMayReduceSuperpixelCount) {
    LTriDPSuperpixelSLIC slic(test_image, test_texture);
    slic.iterate(5);
    
    int count_before = slic.getNumberOfSuperpixels();
    slic.enforceLabelConnectivity(25);
    int count_after = slic.getNumberOfSuperpixels();
    
    // May merge small regions, so count can decrease or stay same
    EXPECT_LE(count_after, count_before);
}

// ============================================================================
// Texture-Aware Distance Tests
// ============================================================================

TEST_F(LTriDPSLICTest, TextureDifferenceAffectsSegmentation) {
    // Create two images with different texture patterns
    cv::Mat uniform_texture = cv::Mat::zeros(100, 100, CV_8UC1);
    cv::Mat varied_texture(100, 100, CV_8UC1);
    
    for (int y = 0; y < 100; ++y) {
        for (int x = 0; x < 100; ++x) {
            varied_texture.at<uchar>(y, x) = static_cast<uchar>((x + y) % 255);
        }
    }
    
    LTriDPSuperpixelSLIC slic_uniform(test_image, uniform_texture);
    LTriDPSuperpixelSLIC slic_varied(test_image, varied_texture);
    
    slic_uniform.iterate(10);
    slic_varied.iterate(10);
    
    cv::Mat labels_uniform, labels_varied;
    slic_uniform.getLabels(labels_uniform);
    slic_varied.getLabels(labels_varied);
    
    // Labels should differ due to texture influence
    int diff_count = cv::countNonZero(labels_uniform != labels_varied);
    EXPECT_GT(diff_count, 0);
}

// ============================================================================
// Compactness Parameter Tests
// ============================================================================

TEST_F(LTriDPSLICTest, HigherCompactnessProducesRegularSuperpixels) {
    LTriDPSuperpixelSLIC slic_low(test_image, test_texture, 20, 5.0f);
    LTriDPSuperpixelSLIC slic_high(test_image, test_texture, 20, 20.0f);
    
    slic_low.iterate(10);
    slic_high.iterate(10);
    
    // Both should produce valid results
    EXPECT_GT(slic_low.getNumberOfSuperpixels(), 0);
    EXPECT_GT(slic_high.getNumberOfSuperpixels(), 0);
    
    // Higher compactness should produce more regular shapes
    // (difficult to test quantitatively without shape analysis)
}

// ============================================================================
// Edge Cases
// ============================================================================

TEST_F(LTriDPSLICTest, HandlesUniformImage) {
    cv::Mat uniform = cv::Mat(100, 100, CV_8UC1, cv::Scalar(128));
    cv::Mat uniform_tex = cv::Mat(100, 100, CV_8UC1, cv::Scalar(100));
    
    EXPECT_NO_THROW({
        LTriDPSuperpixelSLIC slic(uniform, uniform_tex);
        slic.iterate(5);
    });
}

TEST_F(LTriDPSLICTest, HandlesHighContrastImage) {
    cv::Mat checkerboard(100, 100, CV_8UC1);
    cv::Mat checkerboard_tex(100, 100, CV_8UC1);
    
    for (int y = 0; y < 100; ++y) {
        for (int x = 0; x < 100; ++x) {
            checkerboard.at<uchar>(y, x) = ((x / 10 + y / 10) % 2) ? 255 : 0;
            checkerboard_tex.at<uchar>(y, x) = ((x / 10 + y / 10) % 2) ? 200 : 50;
        }
    }
    
    EXPECT_NO_THROW({
        LTriDPSuperpixelSLIC slic(checkerboard, checkerboard_tex);
        slic.iterate(10);
    });
}

TEST_F(LTriDPSLICTest, HandlesSmallImage) {
    cv::Mat small_img(20, 20, CV_8UC1, cv::Scalar(100));
    cv::Mat small_tex(20, 20, CV_8UC1, cv::Scalar(50));
    
    EXPECT_NO_THROW({
        LTriDPSuperpixelSLIC slic(small_img, small_tex, 5);
        slic.iterate(5);
    });
}

// ============================================================================
// Determinism Tests
// ============================================================================

TEST_F(LTriDPSLICTest, ProducesDeterministicResults) {
    // Run twice with same inputs
    LTriDPSuperpixelSLIC slic1(test_image, test_texture, 20, 10.0f);
    slic1.iterate(10);
    
    LTriDPSuperpixelSLIC slic2(test_image, test_texture, 20, 10.0f);
    slic2.iterate(10);
    
    cv::Mat labels1, labels2;
    slic1.getLabels(labels1);
    slic2.getLabels(labels2);
    
    // Results should be identical
    cv::Mat diff = labels1 != labels2;
    EXPECT_EQ(cv::countNonZero(diff), 0);
}

// ============================================================================
// Main
// ============================================================================

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
